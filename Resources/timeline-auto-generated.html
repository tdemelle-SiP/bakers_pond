<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>42 Mill Street Timeline: Auto-Generated</title>
    <link rel="stylesheet" href="timeline-styles.css">
    <script>
        // Add timestamp to force reload on each visit
        if (!window.location.search.includes('v=')) {
            window.location.search = '?v=' + Date.now();
        }
    </script>
    
</head>
<body>
    <nav class="sticky-nav">
        <div class="nav-top-row">
            <a href="https://github.com/tdemelle-SiP/bakers_pond/blob/master/!README.md" class="nav-link">‚Üê Back to README</a>
            <div class="nav-title">42 Mill Street Timeline (Auto-Generated)</div>
            <div id="nav-stats" class="stats-container"></div>
        </div>
        <div class="nav-bottom-row">
            <div id="nav-legend" class="legend"></div>
        </div>
        <div class="nav-filter-row">
            <div class="date-filter-group">
                <div class="filter-group">
                    <label class="filter-label">From:</label>
                    <input type="date" id="filter-start-date" class="filter-input" value="2014-01-01">
                </div>
                <div class="filter-group">
                    <label class="filter-label">To:</label>
                    <input type="date" id="filter-end-date" class="filter-input" value="2025-12-31">
                </div>
                <button id="apply-filters" class="filter-button">Apply Date Range</button>
            </div>
            <div class="filter-group">
                <label class="filter-label">Case:</label>
                <div class="case-filter-container">
                    <button id="case-filter-button" class="case-filter-button">
                        <span id="case-filter-text">All Cases</span>
                        <span class="dropdown-arrow">‚ñº</span>
                    </button>
                    <div id="case-filter-dropdown" class="case-filter-dropdown" style="display: none;">
                        <div class="case-filter-controls">
                            <button class="select-all-btn" onclick="selectAllCases()">Select All</button>
                            <button class="clear-all-btn" onclick="clearAllCases()">Clear All</button>
                        </div>
                        <div id="filter-case" class="case-checkbox-list">
                        </div>
                    </div>
                </div>
            </div>
            <button id="reset-filters" class="filter-button">Reset</button>
            <div class="filter-group" style="margin-left: 20px;">
                <label class="filter-label">Scale:</label>
                <input type="range" id="scale-slider" class="filter-input" min="0.2" max="3" step="0.1" value="0.8" style="width: 100px;">
                <span id="scale-value" class="filter-label">0.8</span>
            </div>
            <div class="filter-group">
                <label class="filter-label">
                    <input type="checkbox" id="fit-to-window" style="margin-right: 5px;">
                    Fit to window
                </label>
            </div>
        </div>
    </nav>
    
    <div class="main-content">
        <div class="container">
        <div id="loading" class="loading">Loading timeline data...</div>
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="timeline-content" style="display: none;">
            <div class="timeline-container" id="timeline-container"></div>
        </div>
    </div>
    
    <script>
        // Global variables
        let allEvents = [];
        let filteredEvents = [];
        let currentDateRange = null;
        
        // Case filter dropdown functions
        function toggleCaseDropdown() {
            const dropdown = document.getElementById('case-filter-dropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }
        
        function selectAllCases() {
            document.querySelectorAll('#filter-case input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = true;
            });
            updateCaseFilterText();
            applyFilters(); // Apply filters immediately
        }
        
        function clearAllCases() {
            document.querySelectorAll('#filter-case input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateCaseFilterText();
            applyFilters(); // Apply filters immediately
        }
        
        function updateCaseFilterText() {
            const checkboxes = document.querySelectorAll('#filter-case input[type="checkbox"]');
            const checkedBoxes = document.querySelectorAll('#filter-case input[type="checkbox"]:checked');
            const filterText = document.getElementById('case-filter-text');
            
            if (checkedBoxes.length === 0) {
                filterText.textContent = 'No cases selected';
            } else if (checkedBoxes.length === checkboxes.length) {
                filterText.textContent = 'All Cases';
            } else {
                filterText.textContent = checkedBoxes.length + ' case(s) selected';
            }
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const container = document.querySelector('.case-filter-container');
            if (container && !container.contains(event.target)) {
                document.getElementById('case-filter-dropdown').style.display = 'none';
            }
        });
        
        // Timeline data parser and renderer
        async function loadTimeline() {
            try {
                // Fetch the timeline overview markdown file with cache busting
                const response = await fetch('../!42_Mill_St_Timeline_Overview.md?v=' + Date.now());
                if (!response.ok) throw new Error('Failed to load timeline data');
                
                const text = await response.text();
                allEvents = parseTimelineData(text);
                
                if (allEvents.length === 0) {
                    throw new Error('No events found in timeline data');
                }
                
                // Populate case number filter
                populateCaseFilter(allEvents);
                
                // Set up filter handlers first to load saved preferences
                setupFilterHandlers();
                
                // Apply saved filters if they exist
                const savedStartDate = localStorage.getItem('timeline-start-date');
                const savedEndDate = localStorage.getItem('timeline-end-date');
                const savedCases = localStorage.getItem('timeline-selected-cases');
                
                if (savedStartDate || savedEndDate || savedCases) {
                    // Apply saved filters
                    applyFilters();
                } else {
                    // Initial render with all events and saved scale
                    filteredEvents = allEvents;
                    
                    // Check if fit-to-window is enabled
                    const fitToWindowEnabled = localStorage.getItem('timeline-fit-to-window') === 'true';
                    if (fitToWindowEnabled) {
                        // First render to establish date range
                        renderTimeline(filteredEvents);
                        // Then calculate and apply fit scale
                        setTimeout(calculateAndApplyFitScale, 0);
                    } else {
                        const savedScale = localStorage.getItem('timeline-scale');
                        renderTimeline(filteredEvents, savedScale ? parseFloat(savedScale) : null);
                    }
                }
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('timeline-content').style.display = 'block';
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = 'Error: ' + error.message;
            }
        }
        
        function populateCaseFilter(events) {
            const caseNumbers = new Set();
            events.forEach(event => {
                if (event.caseNumber && event.caseNumber.trim() !== '') {
                    caseNumbers.add(event.caseNumber);
                }
            });
            
            const container = document.getElementById('filter-case');
            container.innerHTML = ''; // Clear existing content
            
            // Check if there are any events without case numbers
            const hasUnassignedEvents = events.some(event => !event.caseNumber || event.caseNumber.trim() === '');
            
            // Add checkbox for unassigned events first if they exist
            if (hasUnassignedEvents) {
                const label = document.createElement('label');
                label.className = 'case-checkbox-label';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = 'UNASSIGNED';
                checkbox.checked = true; // Default to all selected
                checkbox.className = 'case-checkbox';
                checkbox.addEventListener('change', () => {
                    updateCaseFilterText();
                    // Save selected cases when changed
                    const checkedCases = Array.from(document.querySelectorAll('#filter-case input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    localStorage.setItem('timeline-selected-cases', JSON.stringify(checkedCases));
                    applyFilters(); // Apply filters immediately
                });
                
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(' Unassigned'));
                container.appendChild(label);
            }
            
            // Add the known DEP case numbers in chronological order
            const knownCases = [
                { value: '338-0303', text: 'DEP #338-0303' },
                { value: '338-0594', text: 'DEP #338-0594' },
                { value: '338-0706', text: 'DEP #338-0706' },
                { value: '338-0756', text: 'DEP #338-0756' }
            ];
            
            // Add checkboxes for known cases that exist in the data
            knownCases.forEach(caseInfo => {
                if (caseNumbers.has(caseInfo.value)) {
                    const label = document.createElement('label');
                    label.className = 'case-checkbox-label';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = caseInfo.value;
                    checkbox.checked = true; // Default to all selected
                    checkbox.className = 'case-checkbox';
                    checkbox.addEventListener('change', () => {
                        updateCaseFilterText();
                        applyFilters(); // Apply filters immediately
                    });
                    
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(' ' + caseInfo.text));
                    container.appendChild(label);
                }
            });
            
            // Add any other case numbers not in our known list (excluding WET numbers)
            Array.from(caseNumbers).sort().forEach(caseNum => {
                if (!knownCases.some(k => k.value === caseNum) && !caseNum.startsWith('WET')) {
                    const label = document.createElement('label');
                    label.className = 'case-checkbox-label';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = caseNum;
                    checkbox.checked = true; // Default to all selected
                    checkbox.className = 'case-checkbox';
                    checkbox.addEventListener('change', () => {
                        updateCaseFilterText();
                        applyFilters(); // Apply filters immediately
                    });
                    
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(' DEP #' + caseNum));
                    container.appendChild(label);
                }
            });
            
            // Add click handler to the filter button
            document.getElementById('case-filter-button').addEventListener('click', toggleCaseDropdown);
            
            // Initialize the filter text
            updateCaseFilterText();
        }
        
        function setupFilterHandlers() {
            document.getElementById('apply-filters').addEventListener('click', applyFilters);
            document.getElementById('reset-filters').addEventListener('click', resetFilters);
            
            // Load saved date range from localStorage
            const savedStartDate = localStorage.getItem('timeline-start-date');
            const savedEndDate = localStorage.getItem('timeline-end-date');
            if (savedStartDate) {
                document.getElementById('filter-start-date').value = savedStartDate;
            }
            if (savedEndDate) {
                document.getElementById('filter-end-date').value = savedEndDate;
            }
            
            // Load saved case selections from localStorage
            const savedCases = localStorage.getItem('timeline-selected-cases');
            if (savedCases) {
                const selectedCases = JSON.parse(savedCases);
                document.querySelectorAll('#filter-case input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = selectedCases.includes(checkbox.value);
                });
                updateCaseFilterText();
            }
            
            // Scale slider handler
            const scaleSlider = document.getElementById('scale-slider');
            const scaleValue = document.getElementById('scale-value');
            
            // Load saved scale from localStorage
            const savedScale = localStorage.getItem('timeline-scale');
            if (savedScale) {
                const scale = parseFloat(savedScale);
                scaleSlider.value = scale;
                scaleValue.textContent = scale.toFixed(1);
            }
            
            scaleSlider.addEventListener('input', (e) => {
                const scale = parseFloat(e.target.value);
                scaleValue.textContent = scale.toFixed(1);
                
                // Save scale to localStorage
                localStorage.setItem('timeline-scale', scale);
                
                // Disable fit-to-window when manually adjusting scale
                document.getElementById('fit-to-window').checked = false;
                localStorage.setItem('timeline-fit-to-window', 'false');
                
                renderTimeline(filteredEvents, scale);
            });
            
            // Fit to window handler
            const fitToWindow = document.getElementById('fit-to-window');
            
            // Load saved fit-to-window preference
            const savedFitToWindow = localStorage.getItem('timeline-fit-to-window') === 'true';
            fitToWindow.checked = savedFitToWindow;
            
            fitToWindow.addEventListener('change', (e) => {
                localStorage.setItem('timeline-fit-to-window', e.target.checked);
                
                if (e.target.checked) {
                    calculateAndApplyFitScale();
                } else {
                    // Revert to saved scale or default
                    const savedScale = localStorage.getItem('timeline-scale');
                    const scale = savedScale ? parseFloat(savedScale) : 0.8;
                    scaleSlider.value = scale;
                    scaleValue.textContent = scale.toFixed(1);
                    renderTimeline(filteredEvents, scale);
                }
            });
            
            // Listen for window resize to maintain fit
            window.addEventListener('resize', () => {
                if (fitToWindow.checked) {
                    calculateAndApplyFitScale();
                }
            });
        }
        
        function applyFilters() {
            const startDateInput = document.getElementById('filter-start-date');
            const endDateInput = document.getElementById('filter-end-date');
            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            
            // Save date range to localStorage
            localStorage.setItem('timeline-start-date', startDateInput.value);
            localStorage.setItem('timeline-end-date', endDateInput.value);
            
            // Get all checked case checkboxes
            const checkedCases = Array.from(document.querySelectorAll('#filter-case input[type="checkbox"]:checked'))
                .map(checkbox => checkbox.value);
            
            // Save selected cases to localStorage
            localStorage.setItem('timeline-selected-cases', JSON.stringify(checkedCases));
            
            filteredEvents = allEvents.filter(event => {
                // Date range filter
                if (event.date < startDate || event.date > endDate) {
                    return false;
                }
                
                // Case number filter - simple check if the event's case (or UNASSIGNED) is in checked list
                const eventCase = event.caseNumber && event.caseNumber.trim() !== '' ? event.caseNumber : 'UNASSIGNED';
                return checkedCases.includes(eventCase);
            });
            
            // Preserve current scale and scroll position when filtering
            const currentScale = parseFloat(document.getElementById('scale-slider').value);
            const mainContent = document.querySelector('.main-content');
            const currentScroll = mainContent ? mainContent.scrollLeft : 0;
            
            renderTimeline(filteredEvents, currentScale);
            
            // Restore scroll position after render
            if (mainContent) {
                mainContent.scrollLeft = currentScroll;
            }
        }
        
        function resetFilters() {
            document.getElementById('filter-start-date').value = '2014-01-01';
            document.getElementById('filter-end-date').value = '2025-12-31';
            
            // Check all case checkboxes
            document.querySelectorAll('#filter-case input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Clear saved filter values from localStorage
            localStorage.removeItem('timeline-start-date');
            localStorage.removeItem('timeline-end-date');
            localStorage.removeItem('timeline-selected-cases');
            
            filteredEvents = allEvents;
            renderTimeline(filteredEvents);
        }
        
        function calculateAndApplyFitScale() {
            if (filteredEvents.length === 0) return;
            
            // Get viewport width
            const viewportWidth = window.innerWidth - 140; // Account for padding and margins
            
            // Calculate required scale to fit timeline
            if (currentDateRange) {
                const { startDate, endDate, totalDays } = currentDateRange;
                // Calculate scale that would fit the timeline in viewport
                const requiredScale = (viewportWidth - 100) / totalDays;
                
                // Clamp to slider range
                const clampedScale = Math.max(0.2, Math.min(3, requiredScale));
                
                // Update slider and render
                const scaleSlider = document.getElementById('scale-slider');
                const scaleValue = document.getElementById('scale-value');
                scaleSlider.value = clampedScale;
                scaleValue.textContent = clampedScale.toFixed(1);
                
                renderTimeline(filteredEvents, clampedScale);
            }
        }
        
        function parseTimelineData(text) {
            const lines = text.split('\n');
            const events = [];
            
            // Skip header lines and find the table
            let inTable = false;
            for (const line of lines) {
                if (line.includes('| Date | Document | Case # | Mrkr |')) {
                    inTable = true;
                    continue;
                }
                if (!inTable) continue;
                if (line.trim() === '' || line.startsWith('|------')) continue;
                
                // Parse table row
                const parts = line
                    .split('|')          // keep every cell, even empty ones
                    .slice(1, -1)        // throw away the leading & trailing '' from the |‚Ä¶| row
                    .map(p => p.trim());
                
                if (parts.length !== 7) continue;  // guard, but will now pass for blank-case rows
                
                const [dateStr, document, caseNumber, markers, procedural, legal, environmental] = parts;
                
                // Parse date
                const dateParts = dateStr.split('-');
                if (dateParts.length !== 3) continue;
                
                const date = new Date(dateParts[0], parseInt(dateParts[1]) - 1, dateParts[2]);
                if (isNaN(date.getTime())) continue;
                
                // Extract title from document link or text
                let title = document;
                const linkMatch = document.match(/\[([^\]]+)\]/);
                if (linkMatch) {
                    title = linkMatch[1];
                }
                
                // Clean up title
                title = title.replace(/_/g, ' ')
                           .replace(/MISSING:/g, '‚ùå')
                           .replace(/\.txt$/g, '')
                           .replace(/\.pdf$/g, '');
                
                // Determine event type based on markers and content
                const markerTypes = {
                    'üü°': 'critical-moment',
                    'üî¥': 'privileged',
                    'üê¢': 'continuance'
                };
                
                let eventClass = '';
                let isPrivate = false;
                
                // Check markers (‚ùå is now only a secondary indicator)
                for (const [marker, className] of Object.entries(markerTypes)) {
                    if (markers.includes(marker)) {
                        eventClass = className;
                        break;
                    }
                }
                
                // Always check for üî¥ to set isPrivate, regardless of other markers
                if (markers.includes('üî¥')) {
                    isPrivate = true;
                }
                
                // If no primary marker found, skip this event
                if (!eventClass) {
                    continue;
                }
                
                // Extract key procedural text (preserve bold markers for parsing)
                let detail = procedural.trim();
                
                // Debug raw procedural value
                if (caseNumber && (procedural.includes('filed') || procedural.includes('issued') || procedural.includes('denied'))) {
                    console.log(`Raw procedural for ${caseNumber}:`, procedural);
                }
                
                // Create display version without asterisks for tooltip
                let displayDetail = detail.replace(/\*\*/g, '').replace(/^["]+|["]+$/g, '').trim();
                if (displayDetail.length > 100) {
                    displayDetail = displayDetail.substring(0, 97) + '...';
                }
                
                events.push({
                    date: date,
                    dateStr: dateStr,
                    title: title,
                    detail: detail,  // Raw detail with bold markers
                    displayDetail: displayDetail,  // Clean version for display
                    eventClass: eventClass,
                    isPrivate: isPrivate,
                    markers: markers,
                    caseNumber: caseNumber
                });
            }
            
            return events.sort((a, b) => a.date - b.date);
        }
        
        function renderTimeline(events, customScale = null) {
            // Create legend
            const legendItems = [
                { class: 'normal-public', label: 'Public Events' },
                { class: 'privileged', label: 'Shadow Events' }
            ];
            
            // Add missing document indicator to legend
            const missingLegend = document.createElement('div');
            missingLegend.className = 'nav-legend-item';
            missingLegend.innerHTML = '<span style="color: #d32f2f; font-weight: bold; font-size: 12px;">‚úï</span><span style="margin-left: 8px;">Missing Document (‚ùå)</span>';
            
            const legendEl = document.getElementById('nav-legend');
            legendEl.innerHTML = ''; // Clear existing legend items
            legendItems.forEach(item => {
                const div = document.createElement('div');
                div.className = 'nav-legend-item';
                div.innerHTML = `
                    <div class="legend-box ${item.class}" style="
                        background: var(--bg);
                        border-color: var(--border);
                        ${item.class === 'missing-file' ? 'border-style: dashed;' : ''}
                    "></div>
                    <span>${item.label}</span>
                `;
                
                // Set CSS variables for legend colors
                const box = div.querySelector('.legend-box');
                const styles = getComputedStyle(document.createElement('div'));
                if (item.class === 'normal-public') {
                    box.style.background = '#4caf50';
                    box.style.borderColor = '#388e3c';
                } else if (item.class === 'privileged') {
                    box.style.background = '#f44336';
                    box.style.borderColor = '#d32f2f';
                }
                
                legendEl.appendChild(div);
            });
            
            // Add missing document indicator to legend
            legendEl.appendChild(missingLegend);
            
            // Create timeline container content
            const container = document.getElementById('timeline-container');
            
            // Add labels and background sections
            container.innerHTML = `
                <div class="timeline-section-background public-section"></div>
                <div class="timeline-section-background private-section"></div>
                <div class="section-label public-label">PUBLIC PROCEEDINGS</div>
                <div class="section-label private-label">SHADOW PROCEEDINGS</div>
                <div class="timeline-line"></div>
            `;
            
            // Calculate date range dynamically from events
            const dates = events.map(e => e.date);
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            
            // Add padding to the date range
            const startDate = new Date(minDate.getFullYear(), 0, 1);
            const endDate = new Date(maxDate.getFullYear() + 1, 11, 31);
            
            const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
            
            // Store date range globally for fit-to-window calculations
            currentDateRange = { startDate, endDate, totalDays };
            
            const pixelsPerDay = customScale || parseFloat(document.getElementById('scale-slider')?.value) || 0.8;
            const timelineWidth = Math.max(totalDays * pixelsPerDay + 100, 1200);
            
            // Set the container width dynamically
            container.style.width = timelineWidth + 'px';
            container.parentElement.style.width = (timelineWidth + 80) + 'px';
            
            // Add year markers and labels dynamically
            const yearPositions = [];
            for (let year = startDate.getFullYear(); year <= endDate.getFullYear(); year++) {
                const yearDate = new Date(year, 0, 1);
                const daysFromStart = (yearDate - startDate) / (1000 * 60 * 60 * 24);
                const x = 50 + (daysFromStart * pixelsPerDay);
                
                if (x >= 50 && x <= timelineWidth - 50) {
                    // Add marker
                    const marker = document.createElement('div');
                    marker.className = 'year-marker';
                    marker.style.left = x + 'px';
                    container.appendChild(marker);
                    
                    yearPositions.push({ year, x });
                }
            }
            
            // Add year labels between markers
            for (let i = 0; i < yearPositions.length - 1; i++) {
                const current = yearPositions[i];
                const next = yearPositions[i + 1];
                const midX = (current.x + next.x) / 2;
                
                const label = document.createElement('div');
                label.className = 'year-label';
                label.style.left = midX + 'px';
                label.textContent = current.year;
                container.appendChild(label);
            }
            
            // Add last year label if there's space
            if (yearPositions.length > 0) {
                const last = yearPositions[yearPositions.length - 1];
                if (timelineWidth - last.x > 100) {
                    const label = document.createElement('div');
                    label.className = 'year-label';
                    label.style.left = (last.x + timelineWidth - 50) / 2 + 'px';
                    label.textContent = last.year;
                    container.appendChild(label);
                }
            }
            
            // Add events and track positions
            const eventPositions = [];
            const labelPositions = { above: [], below: [] };
            const datesWithLabels = { above: new Set(), below: new Set() };
            const allDateLabels = { above: [], below: [] };
            
            // Track case procedural events for timeline bars
            const caseProceduralEvents = {
                '338-0303': [],
                '338-0594': [],
                '338-0706': [],
                '338-0756': []
            };
            
            // Debug: log event count and breakdown
            console.log(`Rendering ${events.length} events`);
            const publicCount = events.filter(e => !e.isPrivate).length;
            const privateCount = events.filter(e => e.isPrivate).length;
            console.log(`Public: ${publicCount}, Private: ${privateCount}`);
            
            // Debug: Check first few events to see data structure
            console.log('First 3 events with case numbers:', 
                events.filter(e => e.caseNumber).slice(0, 3).map(e => ({
                    date: e.dateStr,
                    case: e.caseNumber,
                    detail: e.detail
                }))
            );
            
            // PASS 1: Regular timeline events
            events.forEach((event, index) => {
                const daysFromStart = (event.date - startDate) / (1000 * 60 * 60 * 24);
                const x = 50 + (daysFromStart * pixelsPerDay);
                
                const eventEl = document.createElement('div');
                // For private events, always use 'privileged' class for red color
                const colorClass = event.isPrivate ? 'privileged' : event.eventClass;
                eventEl.className = `event ${colorClass} ${event.isPrivate ? 'event-below' : 'event-above'}`;
                eventEl.style.left = x + 'px';
                
                // Only create date label if we haven't already created one for this date/level
                const labelGroup = event.isPrivate ? 'below' : 'above';
                const dateKey = event.dateStr;
                const monthDay = new Date(event.date).toLocaleDateString('en-US', { month: 'numeric', day: 'numeric' });
                
                if (!datesWithLabels[labelGroup].has(dateKey)) {
                    // Create date label (month/day)
                    const dateLabel = document.createElement('div');
                    dateLabel.className = 'event-date-label';
                    dateLabel.textContent = monthDay;
                    
                    // Store label info for later processing
                    allDateLabels[labelGroup].push({
                        element: dateLabel,
                        x: x,
                        date: event.date,
                        eventEl: eventEl
                    });
                    
                    // Mark this date as having a label
                    datesWithLabels[labelGroup].add(dateKey);
                }
                
                // Create tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'event-tooltip';
                tooltip.innerHTML = `
                    <div class="event-date">${event.dateStr}</div>
                    <div class="event-title">${event.title}</div>
                    ${event.displayDetail ? `<div class="event-detail">${event.displayDetail}</div>` : ''}
                `;
                
                eventEl.appendChild(tooltip);
                
                // Check if this event also has missing document marker
                if (event.markers.includes('‚ùå')) {
                    const missingX = document.createElement('div');
                    missingX.className = 'missing-indicator';
                    missingX.textContent = '‚úï';
                    eventEl.appendChild(missingX);
                }
                
                container.appendChild(eventEl);
                
                // Track position for connections
                eventPositions.push({
                    x: x,
                    isPrivate: event.isPrivate,
                    event: event
                });
            });
            
            // Process date labels with two-pass approach
            ['above', 'below'].forEach(position => {
                const labels = allDateLabels[position];
                if (labels.length === 0) return;
                
                // Sort labels by x position
                labels.sort((a, b) => a.x - b.x);
                
                // PASS 1: Identify clusters of overlapping NODES (5px squares)
                const nodeClusterBoundaries = [];
                let clusterStart = 0;
                
                for (let i = 1; i < labels.length; i++) {
                    // If nodes are more than 8px apart, end the current cluster
                    if (labels[i].x - labels[i-1].x > 8) {
                        nodeClusterBoundaries.push({ start: clusterStart, end: i - 1 });
                        clusterStart = i;
                    }
                }
                // Add the last cluster
                nodeClusterBoundaries.push({ start: clusterStart, end: labels.length - 1 });
                
                // Mark which labels to keep from node clustering
                const keepFromNodePass = new Set();
                nodeClusterBoundaries.forEach(cluster => {
                    keepFromNodePass.add(cluster.start); // Always keep first
                    if (cluster.end > cluster.start) {
                        keepFromNodePass.add(cluster.end); // Keep last if different
                    }
                });
                
                // PASS 2: Remove any date that is within 25 pixels of a previous date
                const finalLabelsToShow = [];
                let lastShownX = -Infinity;
                
                labels.forEach((label, index) => {
                    if (!keepFromNodePass.has(index)) return; // Skip if removed in pass 1
                    
                    if (label.x - lastShownX >= 25) {
                        // This label is far enough from the last shown one
                        finalLabelsToShow.push(label);
                        lastShownX = label.x;
                    }
                    // Otherwise, skip this label (it's too close to the previous one)
                });
                
                // Apply the final labels
                finalLabelsToShow.forEach(label => {
                    label.eventEl.appendChild(label.element);
                });
            });
            
            // Add chronological connection lines
            for (let i = 0; i < eventPositions.length - 1; i++) {
                const current = eventPositions[i];
                const next = eventPositions[i + 1];
                
                if (current.isPrivate === next.isPrivate) {
                    // Same level - horizontal line
                    const line = document.createElement('div');
                    line.className = `connection-line ${current.isPrivate ? 'private' : 'public'}`;
                    line.style.left = current.x + 'px';
                    line.style.width = (next.x - current.x) + 'px';
                    container.appendChild(line);
                } else {
                    // Different levels - diagonal line
                    const startY = current.isPrivate ? 322 : 288; // Center of events (317+5, 283+5)
                    const endY = next.isPrivate ? 322 : 288;
                    const height = Math.abs(endY - startY);
                    const width = next.x - current.x;
                    
                    // Create SVG for diagonal line
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.position = 'absolute';
                    svg.style.left = current.x + 'px';
                    svg.style.top = Math.min(startY, endY) + 'px';
                    svg.style.width = width + 'px';
                    svg.style.height = height + 'px';
                    svg.style.zIndex = '5';
                    svg.style.pointerEvents = 'none';
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', '0');
                    line.setAttribute('y1', startY < endY ? '0' : height);
                    line.setAttribute('x2', width);
                    line.setAttribute('y2', startY < endY ? height : '0');
                    line.setAttribute('stroke', '#ff5722');
                    line.setAttribute('stroke-width', '1');
                    
                    svg.appendChild(line);
                    container.appendChild(svg);
                }
            }
            
            // Draw vertical lines between same-day events
            const eventsByDate = {};
            eventPositions.forEach(pos => {
                if (!eventsByDate[pos.event.dateStr]) {
                    eventsByDate[pos.event.dateStr] = [];
                }
                eventsByDate[pos.event.dateStr].push(pos);
            });
            
            Object.values(eventsByDate).forEach(dayEvents => {
                const publicEvents = dayEvents.filter(e => !e.isPrivate);
                const privateEvents = dayEvents.filter(e => e.isPrivate);
                
                if (publicEvents.length > 0 && privateEvents.length > 0) {
                    // The events are already centered on their x position due to transform: translateX(-50%)
                    const line = document.createElement('div');
                    line.style.position = 'absolute';
                    line.style.left = publicEvents[0].x + 'px';
                    line.style.top = '288px';
                    line.style.width = '1px';
                    line.style.height = '34px';
                    line.style.background = '#f44336';
                    container.appendChild(line);
                }
            });
            
            // PASS 2: Collect procedural events for case timelines
            events.forEach(event => {
                const daysFromStart = (event.date - startDate) / (1000 * 60 * 60 * 24);
                const x = 50 + (daysFromStart * pixelsPerDay);
                
                // Check if this is a procedural event
                const isProcedural = event.caseNumber && event.detail !== '‚Äî';
                
                if (isProcedural && event.caseNumber && caseProceduralEvents[event.caseNumber]) {
                    // Extract title and status
                    let proceduralTitle = event.detail.replace(/\*\*/g, '').trim();
                    proceduralTitle = proceduralTitle.replace(/\s*\(.*?\)\s*.*$/, '');
                    
                    // Simple emoji-based status
                    let proceduralStatus = null;
                    if (event.detail.includes('‚≠ê')) {
                        proceduralStatus = 'pending';
                    } else if (event.detail.includes('üõë')) {
                        proceduralStatus = 'denied';
                    } else if (event.detail.includes('‚úÖ')) {
                        proceduralStatus = 'approved';
                    } else if (event.detail.includes('üîí')) {
                        proceduralStatus = 'inherit'; // Special status for behind-closed-doors
                    }
                    
                    caseProceduralEvents[event.caseNumber].push({
                        x: x,
                        date: event.date,
                        dateStr: event.dateStr,
                        title: proceduralTitle,
                        detail: event.detail,
                        status: proceduralStatus,
                        isPrivate: event.isPrivate
                    });
                }
            });
            
            // PASS 3: Render case procedural events and connections
            const caseLabelPositions = []; // Track case label positions for collision detection
            
            Object.entries(caseProceduralEvents).forEach(([caseNum, caseEvents]) => {
                if (caseEvents.length === 0) return;
                
                console.log(`Case ${caseNum} has ${caseEvents.length} procedural events:`, caseEvents);
                
                // Sort events by date
                caseEvents.sort((a, b) => a.date - b.date);
                
                // Add procedural event markers
                caseEvents.forEach((procEvent, idx) => {
                    const procEl = document.createElement('div');
                    procEl.className = `event case-procedural case-${caseNum.slice(-4)} ${procEvent.isPrivate ? 'case-procedural-below' : 'case-procedural-above'}`;
                    procEl.style.left = procEvent.x + 'px';
                    
                    // Set colors based on status
                    if (procEvent.status === 'pending') {
                        procEl.style.backgroundColor = '#ffd700'; // Yellow
                        procEl.style.borderColor = '#ccac00'; // Darker yellow border
                    } else if (procEvent.status === 'denied') {
                        procEl.style.backgroundColor = '#f44336'; // Red
                        procEl.style.borderColor = '#d32f2f'; // Darker red border
                    } else if (procEvent.status === 'approved') {
                        procEl.style.backgroundColor = '#4caf50'; // Green
                        procEl.style.borderColor = '#388e3c'; // Darker green border
                    } else if (procEvent.status === 'inherit' && idx > 0) {
                        // Inherit color from previous node
                        const prevEvent = caseEvents[idx - 1];
                        if (prevEvent.status === 'pending' || (prevEvent.status === 'inherit' && prevEvent.inheritedColor === 'pending')) {
                            procEl.style.backgroundColor = '#ffd700';
                            procEl.style.borderColor = '#ccac00';
                            procEvent.inheritedColor = 'pending';
                        } else if (prevEvent.status === 'denied' || (prevEvent.status === 'inherit' && prevEvent.inheritedColor === 'denied')) {
                            procEl.style.backgroundColor = '#f44336';
                            procEl.style.borderColor = '#d32f2f';
                            procEvent.inheritedColor = 'denied';
                        } else if (prevEvent.status === 'approved' || (prevEvent.status === 'inherit' && prevEvent.inheritedColor === 'approved')) {
                            procEl.style.backgroundColor = '#4caf50';
                            procEl.style.borderColor = '#388e3c';
                            procEvent.inheritedColor = 'approved';
                        }
                    }
                    
                    // Create tooltip
                    const tooltip = document.createElement('div');
                    tooltip.className = 'event-tooltip';
                    tooltip.innerHTML = `
                        <div class="event-date">DEP #${caseNum}</div>
                        <div class="event-title">${procEvent.title}</div>
                        <div class="event-detail">${procEvent.dateStr}</div>
                    `;
                    procEl.appendChild(tooltip);
                    
                    // Add abbreviated label with leader line
                    const procLabel = document.createElement('div');
                    procLabel.style.position = 'absolute';
                    procLabel.style.fontSize = '11px';
                    procLabel.style.fontWeight = '500';
                    procLabel.style.padding = '2px 6px';
                    procLabel.style.background = 'rgba(255, 255, 255, 0.95)';
                    procLabel.style.borderRadius = '3px';
                    procLabel.style.whiteSpace = 'nowrap';
                    procLabel.style.zIndex = '11';
                    procLabel.style.cursor = 'pointer';
                    
                    // Create abbreviation from title
                    let abbreviation = procEvent.title;
                    if (procEvent.title.includes('ANRAD')) {
                        abbreviation = 'ANRAD';
                    } else if (procEvent.title.includes('ANR')) {
                        abbreviation = 'ANR';
                    } else if (procEvent.title.includes('SORAD')) {
                        abbreviation = 'SORAD';
                    } else if (procEvent.title.includes('ORAD')) {
                        abbreviation = 'ORAD';
                    } else if (procEvent.title.includes('FORAD')) {
                        abbreviation = 'FORAD';
                    } else if (procEvent.title.includes('NOI')) {
                        abbreviation = 'NOI';
                    } else if (procEvent.title.includes('OOC')) {
                        abbreviation = 'OOC';
                    } else if (procEvent.title.includes('SOC')) {
                        abbreviation = 'SOC';
                    } else if (procEvent.title.includes('RDA')) {
                        abbreviation = 'RDA';
                    } else if (procEvent.title.includes('Extension')) {
                        abbreviation = 'EXT';
                    } else if (procEvent.title.includes('expires')) {
                        abbreviation = 'EXP';
                    } else if (procEvent.title.includes('Privileged')) {
                        abbreviation = 'PRIV';
                    } else if (procEvent.title.includes('approves')) {
                        abbreviation = 'APPV';
                    }
                    
                    procLabel.textContent = abbreviation;
                    
                    // Add tooltip to label
                    procLabel.title = procEvent.title + ' - ' + procEvent.dateStr;
                    
                    // Add hover effect for label
                    procLabel.addEventListener('mouseenter', () => {
                        procLabel.style.background = 'rgba(255, 255, 255, 1)';
                        procLabel.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                    });
                    procLabel.addEventListener('mouseleave', () => {
                        procLabel.style.background = 'rgba(255, 255, 255, 0.95)';
                        procLabel.style.boxShadow = 'none';
                    });
                    
                    // Calculate label position with collision detection
                    const labelWidth = abbreviation.length * 7 + 12; // Approximate width
                    const labelHeight = 20;
                    const nodeY = procEvent.isPrivate ? 111 : 100;
                    const labelY = procEvent.isPrivate ? nodeY + 20 : nodeY - 30;
                    
                    let labelX = procEvent.x - labelWidth / 2;
                    
                    // Check for collisions and adjust
                    let hasCollision = true;
                    let attempts = 0;
                    while (hasCollision && attempts < 5) {
                        hasCollision = false;
                        for (const existing of caseLabelPositions) {
                            if (Math.abs(labelY - existing.y) < labelHeight &&
                                labelX < existing.x + existing.width &&
                                labelX + labelWidth > existing.x) {
                                hasCollision = true;
                                // Shift right or left based on which side has more space
                                if (labelX < existing.x) {
                                    labelX = existing.x - labelWidth - 5;
                                } else {
                                    labelX = existing.x + existing.width + 5;
                                }
                                break;
                            }
                        }
                        attempts++;
                    }
                    
                    // Position the label
                    procLabel.style.left = labelX + 'px';
                    procLabel.style.top = labelY + 'px';
                    
                    // Calculate leader line endpoints
                    const nodeCenter = procEvent.x;
                    const labelCenter = labelX + labelWidth / 2;
                    const nodeEdge = procEvent.isPrivate ? nodeY + 8 : nodeY;
                    const labelEdge = procEvent.isPrivate ? labelY : labelY + labelHeight;
                    
                    if (Math.abs(nodeCenter - labelCenter) > 5) {
                        // Draw diagonal leader line using SVG
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.style.position = 'absolute';
                        svg.style.left = Math.min(nodeCenter, labelCenter) + 'px';
                        svg.style.top = Math.min(nodeEdge, labelEdge) + 'px';
                        svg.style.width = Math.abs(nodeCenter - labelCenter) + 'px';
                        svg.style.height = Math.abs(nodeEdge - labelEdge) + 'px';
                        svg.style.pointerEvents = 'none';
                        svg.style.zIndex = '9';
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', nodeCenter < labelCenter ? '0' : Math.abs(nodeCenter - labelCenter));
                        line.setAttribute('y1', nodeEdge < labelEdge ? '0' : Math.abs(nodeEdge - labelEdge));
                        line.setAttribute('x2', nodeCenter > labelCenter ? '0' : Math.abs(nodeCenter - labelCenter));
                        line.setAttribute('y2', nodeEdge > labelEdge ? '0' : Math.abs(nodeEdge - labelEdge));
                        line.setAttribute('stroke', '#999');
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('stroke-opacity', '0.7');
                        
                        svg.appendChild(line);
                        container.appendChild(svg);
                    }
                    
                    // Store label position
                    caseLabelPositions.push({
                        x: labelX,
                        y: labelY,
                        width: labelWidth,
                        height: labelHeight
                    });
                    
                    container.appendChild(procLabel);
                    
                    container.appendChild(procEl);
                    
                    // Add connections between same-case procedural events
                    if (idx > 0) {
                        const prevEvent = caseEvents[idx - 1];
                        
                        // Connect all procedural events in the case timeline
                        // Remove the same-level check to allow diagonal connections
                        if (true) {  // Always connect
                            // Create SVG line from center to center
                            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                            svg.style.position = 'absolute';
                            svg.style.left = Math.min(prevEvent.x, procEvent.x) + 'px';
                            svg.style.width = Math.abs(procEvent.x - prevEvent.x) + 'px';
                            svg.style.height = '400px'; // Full container height
                            svg.style.top = '0';
                            svg.style.pointerEvents = 'none';
                            svg.style.overflow = 'visible';
                            
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            
                            // Calculate exact center positions
                            // Node is 8px + 2px border = 10px visual size, center is +5px from position
                            const x1 = prevEvent.x < procEvent.x ? 5 : Math.abs(procEvent.x - prevEvent.x) + 5;
                            const x2 = prevEvent.x < procEvent.x ? Math.abs(procEvent.x - prevEvent.x) + 5 : 5;
                            
                            let y1, y2;
                            // Set Y coordinates based on whether each event is private
                            if (prevEvent.isPrivate) {
                                // Previous private node at 111px, center at 111 + 5 = 116px
                                y1 = 116;
                            } else {
                                // Previous public node at 100px, center at 100 + 5 = 105px
                                y1 = 105;
                            }
                            
                            if (procEvent.isPrivate) {
                                // Current private node at 111px, center at 111 + 5 = 116px
                                y2 = 116;
                            } else {
                                // Current public node at 100px, center at 100 + 5 = 105px
                                y2 = 105;
                            }
                            
                            line.setAttribute('x1', x1);
                            line.setAttribute('y1', y1);
                            line.setAttribute('x2', x2);
                            line.setAttribute('y2', y2);
                            // Line color follows the previous node's status (including inherited)
                            let strokeColor = '#999'; // Default gray
                            if (prevEvent.status === 'pending' || prevEvent.inheritedColor === 'pending') {
                                strokeColor = '#ffd700'; // Yellow
                            } else if (prevEvent.status === 'denied' || prevEvent.inheritedColor === 'denied') {
                                strokeColor = '#f44336'; // Red
                            } else if (prevEvent.status === 'approved' || prevEvent.inheritedColor === 'approved') {
                                strokeColor = '#4caf50'; // Green
                            }
                            line.setAttribute('stroke', strokeColor);
                            line.setAttribute('stroke-width', '4');
                            line.setAttribute('stroke-opacity', '0.7');
                            
                            svg.appendChild(line);
                            container.appendChild(svg);
                            
                            // Add case number label on the middle of the line (only on first connection)
                            if (idx === 1) {
                                const caseLabel = document.createElement('div');
                                caseLabel.className = 'case-label case-label-above';
                                caseLabel.style.left = (prevEvent.x + procEvent.x) / 2 + 'px';
                                // Use the case's original color (not the line color)
                                const caseColorClass = `case-${caseNum.slice(-4)}`;
                                const tempEl = document.createElement('div');
                                tempEl.className = caseColorClass;
                                document.body.appendChild(tempEl);
                                const caseColor = getComputedStyle(tempEl).backgroundColor;
                                document.body.removeChild(tempEl);
                                caseLabel.style.color = caseColor;
                                caseLabel.textContent = `DEP #${caseNum}`;
                                container.appendChild(caseLabel);
                            }
                        }
                    }
                });
            });
            
            // Calculate statistics
            const stats = {
                criticalMoments: events.filter(e => e.markers.includes('üü°')).length,
                missingDocs: events.filter(e => e.markers.includes('‚ùå')).length,
                privileged: events.filter(e => e.markers.includes('üî¥')).length,
                continuances: events.filter(e => e.markers.includes('üê¢')).length,
                totalEvents: events.length
            };
            
            // Render stats
            const statsEl = document.getElementById('nav-stats');
            statsEl.innerHTML = `
                <div class="stat-item">
                    <span class="stat-number">${stats.criticalMoments}</span>
                    <span class="stat-label">Critical</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">${stats.missingDocs}</span>
                    <span class="stat-label">Missing</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">${stats.privileged}</span>
                    <span class="stat-label">Private</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">${stats.continuances}</span>
                    <span class="stat-label">Continued</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number">${stats.totalEvents}</span>
                    <span class="stat-label">Total</span>
                </div>
            `;
        }
        
        // Load timeline when page loads
        window.addEventListener('load', loadTimeline);
        
        // Add mouse wheel horizontal scrolling
        document.addEventListener('wheel', (e) => {
            // Check if we're over the main content area
            const mainContent = document.querySelector('.main-content');
            if (mainContent && mainContent.contains(e.target)) {
                // Prevent vertical scrolling
                e.preventDefault();
                
                // Scroll horizontally instead
                mainContent.scrollLeft += e.deltaY;
            }
        }, { passive: false });
    </script>
</body>
</html>